/// DOM Standard
///
/// https://dom.spec.whatwg.org/

// ignore_for_file: unused_import

@JS('self')
@staticInterop
library dom;

import 'dart:js_util' as js_util;
import 'package:js/js.dart';
import 'package:meta/meta.dart';

import 'package:js_bindings/js_bindings.dart';

/// The interface represents an event which takes place in the DOM.
///  An event can be triggered by the user action e.g. clicking the
/// mouse button or tapping keyboard, or generated by APIs to
/// represent the progress of an asynchronous task. It can also be
/// triggered programmatically, such as by calling the
/// [HTMLElement.click()] method of an element, or by defining the
/// event, then sending it to a specified target using
/// [EventTarget.dispatchEvent()].
///  There are many types of events, some of which use other
/// interfaces based on the main interface. itself contains the
/// properties and methods which are common to all events.
///  Many DOM elements can be set up to accept (or "listen" for)
/// these events, and execute code in response to process (or
/// "handle") them. Event-handlers are usually connected (or
/// "attached") to various HTML elements (such as [<button>],
/// [<div>], [<span>], etc.) using [EventTarget.addEventListener()],
/// and this generally replaces using the old HTML event handler
/// attributes. Further, when properly added, such handlers can also
/// be disconnected if needed using [removeEventListener()].
///
///   Note: One element can have several such handlers, even for the
/// exact same event—particularly if separate, independent code
/// modules attach them, each for its own independent purposes. (For
/// example, a webpage with an advertising-module and
/// statistics-module both monitoring video-watching.)
///
///  When there are many nested elements, each with its own
/// handler(s), event processing can become very
/// complicated—especially where a parent element receives the very
/// same event as its child elements because "spatially" they overlap
/// so the event technically occurs in both, and the processing order
/// of such events depends on the Event bubbling and capture settings
/// of each handler triggered.
@JS()
@staticInterop
class Event {
  external factory Event(String type, [EventInit? eventInitDict]);
  @JS('NONE')
  external static int get none;

  @JS('CAPTURING_PHASE')
  external static int get capturingPhase;

  @JS('AT_TARGET')
  external static int get atTarget;

  @JS('BUBBLING_PHASE')
  external static int get bubblingPhase;
}

extension PropsEvent on Event {
  String get type => js_util.getProperty(this, 'type');
  EventTarget? get target => js_util.getProperty(this, 'target');
  EventTarget? get srcElement => js_util.getProperty(this, 'srcElement');
  EventTarget? get currentTarget => js_util.getProperty(this, 'currentTarget');
  Iterable<EventTarget> composedPath() =>
      js_util.callMethod(this, 'composedPath', []);

  int get eventPhase => js_util.getProperty(this, 'eventPhase');
  void stopPropagation() => js_util.callMethod(this, 'stopPropagation', []);

  bool get cancelBubble => js_util.getProperty(this, 'cancelBubble');
  set cancelBubble(bool newValue) {
    js_util.setProperty(this, 'cancelBubble', newValue);
  }

  void stopImmediatePropagation() =>
      js_util.callMethod(this, 'stopImmediatePropagation', []);

  bool get bubbles => js_util.getProperty(this, 'bubbles');
  bool get cancelable => js_util.getProperty(this, 'cancelable');
  dynamic get returnValue => js_util.getProperty(this, 'returnValue');
  set returnValue(dynamic newValue) {
    js_util.setProperty(this, 'returnValue', newValue);
  }

  void preventDefault() => js_util.callMethod(this, 'preventDefault', []);

  bool get defaultPrevented => js_util.getProperty(this, 'defaultPrevented');
  bool get composed => js_util.getProperty(this, 'composed');
  bool get isTrusted => js_util.getProperty(this, 'isTrusted');
  double get timeStamp => js_util.getProperty(this, 'timeStamp');
  void initEvent(String type,
          [bool? bubbles = false, bool? cancelable = false]) =>
      js_util.callMethod(this, 'initEvent', [type, bubbles, cancelable]);
}

@anonymous
@JS()
@staticInterop
class EventInit {
  external factory EventInit._(
      {bool? bubbles, bool? cancelable, bool? composed});

  factory EventInit({bool? bubbles, bool? cancelable, bool? composed}) =>
      EventInit._(
          bubbles: bubbles ?? false,
          cancelable: cancelable ?? false,
          composed: composed ?? false);
}

extension PropsEventInit on EventInit {
  bool get bubbles => js_util.getProperty(this, 'bubbles');
  set bubbles(bool newValue) {
    js_util.setProperty(this, 'bubbles', newValue);
  }

  bool get cancelable => js_util.getProperty(this, 'cancelable');
  set cancelable(bool newValue) {
    js_util.setProperty(this, 'cancelable', newValue);
  }

  bool get composed => js_util.getProperty(this, 'composed');
  set composed(bool newValue) {
    js_util.setProperty(this, 'composed', newValue);
  }
}

///  The interface represents events initialized by an application
/// for any purpose.
///  Note: This feature is available in Web Workers
///
///
///
///    Event
///
///
///
///
///
///    CustomEvent
///
///
@JS()
@staticInterop
class CustomEvent implements Event {
  external factory CustomEvent(String type, [CustomEventInit? eventInitDict]);
}

extension PropsCustomEvent on CustomEvent {
  dynamic get detail => js_util.getProperty(this, 'detail');
  void initCustomEvent(String type,
          [bool? bubbles = false, bool? cancelable = false, dynamic detail]) =>
      js_util.callMethod(
          this, 'initCustomEvent', [type, bubbles, cancelable, detail]);
}

@anonymous
@JS()
@staticInterop
class CustomEventInit implements EventInit {
  external factory CustomEventInit({dynamic detail});
}

extension PropsCustomEventInit on CustomEventInit {
  dynamic get detail => js_util.getProperty(this, 'detail');
  set detail(dynamic newValue) {
    js_util.setProperty(this, 'detail', newValue);
  }
}

///
///   The interface is implemented by objects that can receive events
/// and may have listeners for them.
///   In other words, any target of events implements the three
/// methods associated with this interface.
///   [Element], and its children, as well as [Document] and
/// [Window], are the most common event targets,
///  but other objects can be event targets, too.
///   For example [XMLHttpRequest], [AudioNode], and [AudioContext]
/// are also event targets.
///
///  Many event targets (including elements, documents, and windows)
/// also support setting event handlers via [onevent] properties and
/// attributes.
@JS()
@staticInterop
class EventTarget {
  external factory EventTarget();
}

extension PropsEventTarget on EventTarget {
  void addEventListener(String type, EventListener? callback,
          [dynamic options]) =>
      js_util.callMethod(this, 'addEventListener',
          [type, callback == null ? null : allowInterop(callback), options]);

  void removeEventListener(String type, EventListener? callback,
          [dynamic options]) =>
      js_util.callMethod(this, 'removeEventListener',
          [type, callback == null ? null : allowInterop(callback), options]);

  bool dispatchEvent(Event event) =>
      js_util.callMethod(this, 'dispatchEvent', [event]);
}

@anonymous
@JS()
@staticInterop
class EventListenerOptions {
  external factory EventListenerOptions._({bool? capture});

  factory EventListenerOptions({bool? capture}) =>
      EventListenerOptions._(capture: capture ?? false);
}

extension PropsEventListenerOptions on EventListenerOptions {
  bool get capture => js_util.getProperty(this, 'capture');
  set capture(bool newValue) {
    js_util.setProperty(this, 'capture', newValue);
  }
}

@anonymous
@JS()
@staticInterop
class AddEventListenerOptions implements EventListenerOptions {
  external factory AddEventListenerOptions._(
      {bool? passive, bool? once, AbortSignal? signal});

  factory AddEventListenerOptions(
          {bool? passive, bool? once, AbortSignal? signal}) =>
      AddEventListenerOptions._(
          passive: passive ?? undefined,
          once: once ?? false,
          signal: signal ?? undefined);
}

extension PropsAddEventListenerOptions on AddEventListenerOptions {
  bool get passive => js_util.getProperty(this, 'passive');
  set passive(bool newValue) {
    js_util.setProperty(this, 'passive', newValue);
  }

  bool get once => js_util.getProperty(this, 'once');
  set once(bool newValue) {
    js_util.setProperty(this, 'once', newValue);
  }

  AbortSignal get signal => js_util.getProperty(this, 'signal');
  set signal(AbortSignal newValue) {
    js_util.setProperty(this, 'signal', newValue);
  }
}

///  The interface represents a controller object that allows you to
/// abort one or more Web requests as and when desired.
///  You can create a new object using the [AbortController()]
/// constructor. Communicating with a DOM request is done using an
/// [AbortSignal] object.
@experimental
@JS()
@staticInterop
class AbortController {
  external factory AbortController();
}

extension PropsAbortController on AbortController {
  AbortSignal get signal => js_util.getProperty(this, 'signal');
  void abort([dynamic reason]) => js_util.callMethod(this, 'abort', [reason]);
}

///  The interface represents a signal object that allows you to
/// communicate with a DOM request (such as a fetch request) and
/// abort it if required via an [AbortController] object.
///
///
///
///    EventTarget
///
///
///
///
///
///    AbortSignal
///
///
@experimental
@JS()
@staticInterop
class AbortSignal implements EventTarget {
  external static AbortSignal abort([dynamic reason]);
  external static AbortSignal timeout(int milliseconds);
  external factory AbortSignal();
}

extension PropsAbortSignal on AbortSignal {
  bool get aborted => js_util.getProperty(this, 'aborted');
  dynamic get reason => js_util.getProperty(this, 'reason');
  void throwIfAborted() => js_util.callMethod(this, 'throwIfAborted', []);

  EventHandlerNonNull? get onabort => js_util.getProperty(this, 'onabort');
  set onabort(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onabort', newValue);
  }
}

@JS()
@staticInterop
class NonElementParentNode {
  external factory NonElementParentNode();
}

extension PropsNonElementParentNode on NonElementParentNode {
  Element? getElementById(String elementId) =>
      js_util.callMethod(this, 'getElementById', [elementId]);
}

@JS()
@staticInterop
class DocumentOrShadowRoot {
  external factory DocumentOrShadowRoot();
}

extension PropsDocumentOrShadowRoot on DocumentOrShadowRoot {
  Iterable<Animation> getAnimations() =>
      js_util.callMethod(this, 'getAnimations', []);

  Element? get pointerLockElement =>
      js_util.getProperty(this, 'pointerLockElement');
  Element? get fullscreenElement =>
      js_util.getProperty(this, 'fullscreenElement');
  Element? get pictureInPictureElement =>
      js_util.getProperty(this, 'pictureInPictureElement');
  Element? get activeElement => js_util.getProperty(this, 'activeElement');
  StyleSheetList get styleSheets => js_util.getProperty(this, 'styleSheets');
  Iterable<CSSStyleSheet> get adoptedStyleSheets =>
      js_util.getProperty(this, 'adoptedStyleSheets');
  set adoptedStyleSheets(Iterable<CSSStyleSheet> newValue) {
    js_util.setProperty(this, 'adoptedStyleSheets', newValue);
  }
}

@JS()
@staticInterop
class ParentNode {
  external factory ParentNode();
}

extension PropsParentNode on ParentNode {
  HTMLCollection get children => js_util.getProperty(this, 'children');
  Element? get firstElementChild =>
      js_util.getProperty(this, 'firstElementChild');
  Element? get lastElementChild =>
      js_util.getProperty(this, 'lastElementChild');
  int get childElementCount => js_util.getProperty(this, 'childElementCount');
  void prepend([dynamic nodes1, dynamic nodes2, dynamic nodes3]) =>
      js_util.callMethod(this, 'prepend', [nodes1, nodes2, nodes3]);

  void append([dynamic nodes1, dynamic nodes2, dynamic nodes3]) =>
      js_util.callMethod(this, 'append', [nodes1, nodes2, nodes3]);

  void replaceChildren([dynamic nodes1, dynamic nodes2, dynamic nodes3]) =>
      js_util.callMethod(this, 'replaceChildren', [nodes1, nodes2, nodes3]);

  Element? querySelector(String selectors) =>
      js_util.callMethod(this, 'querySelector', [selectors]);

  NodeList querySelectorAll(String selectors) =>
      js_util.callMethod(this, 'querySelectorAll', [selectors]);
}

@JS()
@staticInterop
class NonDocumentTypeChildNode {
  external factory NonDocumentTypeChildNode();
}

extension PropsNonDocumentTypeChildNode on NonDocumentTypeChildNode {
  Element? get previousElementSibling =>
      js_util.getProperty(this, 'previousElementSibling');
  Element? get nextElementSibling =>
      js_util.getProperty(this, 'nextElementSibling');
}

@JS()
@staticInterop
class ChildNode {
  external factory ChildNode();
}

extension PropsChildNode on ChildNode {
  void before([dynamic nodes1, dynamic nodes2, dynamic nodes3]) =>
      js_util.callMethod(this, 'before', [nodes1, nodes2, nodes3]);

  void after([dynamic nodes1, dynamic nodes2, dynamic nodes3]) =>
      js_util.callMethod(this, 'after', [nodes1, nodes2, nodes3]);

  void replaceWith([dynamic nodes1, dynamic nodes2, dynamic nodes3]) =>
      js_util.callMethod(this, 'replaceWith', [nodes1, nodes2, nodes3]);

  void remove() => js_util.callMethod(this, 'remove', []);
}

@JS()
@staticInterop
class Slottable {
  external factory Slottable();
}

extension PropsSlottable on Slottable {
  HTMLSlotElement? get assignedSlot =>
      js_util.getProperty(this, 'assignedSlot');
}

///   objects are collections of nodes, usually returned by
/// properties such as [Node.childNodes] and methods such as
/// [document.querySelectorAll()].
///
///   Note: Although is not an [Array], it is possible to iterate
/// over it with [forEach()]. It can also be converted to a real
/// [Array] using [Array.from()].
///   However, some older browsers have not implemented
/// [NodeList.forEach()] nor [Array.from()]. This can be circumvented
/// by using [Array.prototype.forEach()] — see this document's
/// Example.
///
@JS()
@staticInterop
class NodeList extends JsArray<Node> {
  external factory NodeList();
}

extension PropsNodeList on NodeList {
  Node? item(int index) => js_util.callMethod(this, 'item', [index]);

  int get length => js_util.getProperty(this, 'length');
}

///  The interface represents a generic collection (array-like object
/// similar to [arguments]) of elements (in document order) and
/// offers methods and properties for selecting from the list.
///
///   Note: This interface is called for historical reasons (before
/// the modern DOM, collections implementing this interface could
/// only have HTML elements as their items).
///
///  An in the HTML DOM is live; it is automatically updated when the
/// underlying document is changed. For this reason it is a good idea
/// to make a copy (eg. using [Array.from]) to iterate over if
/// adding, moving, or removing nodes.
@JS()
@staticInterop
class HTMLCollection {
  external factory HTMLCollection();
}

extension PropsHTMLCollection on HTMLCollection {
  int get length => js_util.getProperty(this, 'length');
  Element? item(int index) => js_util.callMethod(this, 'item', [index]);

  dynamic namedItem(String name) =>
      js_util.callMethod(this, 'namedItem', [name]);
}

///  The interface provides the ability to watch for changes being
/// made to the DOM tree. It is designed as a replacement for the
/// older Mutation Events feature, which was part of the DOM3 Events
/// specification.
@JS()
@staticInterop
class MutationObserver {
  external factory MutationObserver(MutationCallback callback);
}

extension PropsMutationObserver on MutationObserver {
  void observe(Node target, [MutationObserverInit? options]) =>
      js_util.callMethod(this, 'observe', [target, options]);

  void disconnect() => js_util.callMethod(this, 'disconnect', []);

  Iterable<MutationRecord> takeRecords() =>
      js_util.callMethod(this, 'takeRecords', []);
}

@anonymous
@JS()
@staticInterop
class MutationObserverInit {
  external factory MutationObserverInit._(
      {bool? childList,
      bool? attributes,
      bool? characterData,
      bool? subtree,
      bool? attributeOldValue,
      bool? characterDataOldValue,
      Iterable<String>? attributeFilter});

  factory MutationObserverInit(
          {bool? childList,
          bool? attributes,
          bool? characterData,
          bool? subtree,
          bool? attributeOldValue,
          bool? characterDataOldValue,
          Iterable<String>? attributeFilter}) =>
      MutationObserverInit._(
          childList: childList ?? false,
          attributes: attributes ?? undefined,
          characterData: characterData ?? undefined,
          subtree: subtree ?? false,
          attributeOldValue: attributeOldValue ?? undefined,
          characterDataOldValue: characterDataOldValue ?? undefined,
          attributeFilter: attributeFilter ?? undefined);
}

extension PropsMutationObserverInit on MutationObserverInit {
  bool get childList => js_util.getProperty(this, 'childList');
  set childList(bool newValue) {
    js_util.setProperty(this, 'childList', newValue);
  }

  bool get attributes => js_util.getProperty(this, 'attributes');
  set attributes(bool newValue) {
    js_util.setProperty(this, 'attributes', newValue);
  }

  bool get characterData => js_util.getProperty(this, 'characterData');
  set characterData(bool newValue) {
    js_util.setProperty(this, 'characterData', newValue);
  }

  bool get subtree => js_util.getProperty(this, 'subtree');
  set subtree(bool newValue) {
    js_util.setProperty(this, 'subtree', newValue);
  }

  bool get attributeOldValue => js_util.getProperty(this, 'attributeOldValue');
  set attributeOldValue(bool newValue) {
    js_util.setProperty(this, 'attributeOldValue', newValue);
  }

  bool get characterDataOldValue =>
      js_util.getProperty(this, 'characterDataOldValue');
  set characterDataOldValue(bool newValue) {
    js_util.setProperty(this, 'characterDataOldValue', newValue);
  }

  Iterable<String> get attributeFilter =>
      js_util.getProperty(this, 'attributeFilter');
  set attributeFilter(Iterable<String> newValue) {
    js_util.setProperty(this, 'attributeFilter', newValue);
  }
}

///  A represents an individual DOM mutation. It is the object that
/// is inside the array passed to [MutationObserver]'s callback.
@JS()
@staticInterop
class MutationRecord {
  external factory MutationRecord();
}

extension PropsMutationRecord on MutationRecord {
  String get type => js_util.getProperty(this, 'type');
  Node get target => js_util.getProperty(this, 'target');
  NodeList get addedNodes => js_util.getProperty(this, 'addedNodes');
  NodeList get removedNodes => js_util.getProperty(this, 'removedNodes');
  Node? get previousSibling => js_util.getProperty(this, 'previousSibling');
  Node? get nextSibling => js_util.getProperty(this, 'nextSibling');
  String? get attributeName => js_util.getProperty(this, 'attributeName');
  String? get attributeNamespace =>
      js_util.getProperty(this, 'attributeNamespace');
  String? get oldValue => js_util.getProperty(this, 'oldValue');
}

///
///  The DOM interface is an abstract base
///   class upon which many other DOM API objects are based, thus
/// letting those object types
///   to be used similarly and often interchangeably. As an abstract
/// class, there is
///  no such thing as a plain object. All objects that implement
///    functionality are based on one of its subclasses. Most notable
/// are
///  [Document], [Element], and [DocumentFragment].
///   In addition, every kind of DOM node is represented by an
/// interface based on
///  . These include [Attr], [CharacterData]
///  (which [Text], [Comment], [CDATASection] and
///  [ProcessingInstruction] are all based on), and [DocumentType].
///   In some cases, a particular feature of the base interface may
/// not
///   apply to one of its child interfaces; in that case, the
/// inheriting node may
///   return [null] or throw an exception, depending on
/// circumstances. For example,
///   attempting to add children to a node type that cannot have
/// children will throw an
///  exception.
///
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
@JS()
@staticInterop
class Node implements EventTarget {
  @JS('ELEMENT_NODE')
  external static int get elementNode;

  @JS('ATTRIBUTE_NODE')
  external static int get attributeNode;

  @JS('TEXT_NODE')
  external static int get textNode;

  @JS('CDATA_SECTION_NODE')
  external static int get cdataSectionNode;

  @JS('ENTITY_REFERENCE_NODE')
  external static int get entityReferenceNode;

  @JS('ENTITY_NODE')
  external static int get entityNode;

  @JS('PROCESSING_INSTRUCTION_NODE')
  external static int get processingInstructionNode;

  @JS('COMMENT_NODE')
  external static int get commentNode;

  @JS('DOCUMENT_NODE')
  external static int get documentNode;

  @JS('DOCUMENT_TYPE_NODE')
  external static int get documentTypeNode;

  @JS('DOCUMENT_FRAGMENT_NODE')
  external static int get documentFragmentNode;

  @JS('NOTATION_NODE')
  external static int get notationNode;

  @JS('DOCUMENT_POSITION_DISCONNECTED')
  external static int get documentPositionDisconnected;

  @JS('DOCUMENT_POSITION_PRECEDING')
  external static int get documentPositionPreceding;

  @JS('DOCUMENT_POSITION_FOLLOWING')
  external static int get documentPositionFollowing;

  @JS('DOCUMENT_POSITION_CONTAINS')
  external static int get documentPositionContains;

  @JS('DOCUMENT_POSITION_CONTAINED_BY')
  external static int get documentPositionContainedBy;

  @JS('DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC')
  external static int get documentPositionImplementationSpecific;

  external factory Node();
}

extension PropsNode on Node {
  int get nodeType => js_util.getProperty(this, 'nodeType');
  String get nodeName => js_util.getProperty(this, 'nodeName');
  String get baseURI => js_util.getProperty(this, 'baseURI');
  bool get isConnected => js_util.getProperty(this, 'isConnected');
  Document? get ownerDocument => js_util.getProperty(this, 'ownerDocument');
  Node getRootNode([GetRootNodeOptions? options]) =>
      js_util.callMethod(this, 'getRootNode', [options]);

  Node? get parentNode => js_util.getProperty(this, 'parentNode');
  Element? get parentElement => js_util.getProperty(this, 'parentElement');
  bool hasChildNodes() => js_util.callMethod(this, 'hasChildNodes', []);

  NodeList get childNodes => js_util.getProperty(this, 'childNodes');
  Node? get firstChild => js_util.getProperty(this, 'firstChild');
  Node? get lastChild => js_util.getProperty(this, 'lastChild');
  Node? get previousSibling => js_util.getProperty(this, 'previousSibling');
  Node? get nextSibling => js_util.getProperty(this, 'nextSibling');
  String? get nodeValue => js_util.getProperty(this, 'nodeValue');
  set nodeValue(String? newValue) {
    js_util.setProperty(this, 'nodeValue', newValue);
  }

  String? get textContent => js_util.getProperty(this, 'textContent');
  set textContent(String? newValue) {
    js_util.setProperty(this, 'textContent', newValue);
  }

  void normalize() => js_util.callMethod(this, 'normalize', []);

  Node cloneNode([bool? deep = false]) =>
      js_util.callMethod(this, 'cloneNode', [deep]);

  bool isEqualNode(Node? otherNode) =>
      js_util.callMethod(this, 'isEqualNode', [otherNode]);

  bool isSameNode(Node? otherNode) =>
      js_util.callMethod(this, 'isSameNode', [otherNode]);

  int compareDocumentPosition(Node other) =>
      js_util.callMethod(this, 'compareDocumentPosition', [other]);

  bool contains(Node? other) => js_util.callMethod(this, 'contains', [other]);

  String? lookupPrefix(String? namespace) =>
      js_util.callMethod(this, 'lookupPrefix', [namespace]);

  String? lookupNamespaceURI(String? prefix) =>
      js_util.callMethod(this, 'lookupNamespaceURI', [prefix]);

  bool isDefaultNamespace(String? namespace) =>
      js_util.callMethod(this, 'isDefaultNamespace', [namespace]);

  Node insertBefore(Node node, Node? child) =>
      js_util.callMethod(this, 'insertBefore', [node, child]);

  Node appendChild(Node node) =>
      js_util.callMethod(this, 'appendChild', [node]);

  Node replaceChild(Node node, Node child) =>
      js_util.callMethod(this, 'replaceChild', [node, child]);

  Node removeChild(Node child) =>
      js_util.callMethod(this, 'removeChild', [child]);
}

@anonymous
@JS()
@staticInterop
class GetRootNodeOptions {
  external factory GetRootNodeOptions._({bool? composed});

  factory GetRootNodeOptions({bool? composed}) =>
      GetRootNodeOptions._(composed: composed ?? false);
}

extension PropsGetRootNodeOptions on GetRootNodeOptions {
  bool get composed => js_util.getProperty(this, 'composed');
  set composed(bool newValue) {
    js_util.setProperty(this, 'composed', newValue);
  }
}

///  The interface represents any web page loaded in the browser and
/// serves as an entry point into the web page's content, which is
/// the DOM tree.
///  The DOM tree includes elements such as [<body>] and [<table>],
/// among many others. It provides functionality globally to the
/// document, like how to obtain the page's URL and create new
/// elements in the document.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    Document
///
///
///  The interface describes the common properties and methods for
/// any kind of document. Depending on the document's type (e.g.
/// HTML, XML, SVG, …), a larger API is available: HTML documents,
/// served with the ["text/html"] content type, also implement the
/// [HTMLDocument] interface, whereas XML and SVG documents implement
/// the [XMLDocument] interface.
@JS()
@staticInterop
class Document
    implements
        Node,
        GeometryUtils,
        FontFaceSource,
        NonElementParentNode,
        DocumentOrShadowRoot,
        ParentNode,
        XPathEvaluatorBase,
        GlobalEventHandlers,
        DocumentAndElementEventHandlers {
  external factory Document();
}

extension PropsDocument on Document {
  DOMImplementation get implementation =>
      js_util.getProperty(this, 'implementation');
  String get url => js_util.getProperty(this, 'URL');
  String get documentURI => js_util.getProperty(this, 'documentURI');
  String get compatMode => js_util.getProperty(this, 'compatMode');
  String get characterSet => js_util.getProperty(this, 'characterSet');
  String get charset => js_util.getProperty(this, 'charset');
  String get inputEncoding => js_util.getProperty(this, 'inputEncoding');
  String get contentType => js_util.getProperty(this, 'contentType');
  DocumentType? get doctype => js_util.getProperty(this, 'doctype');
  Element? get documentElement => js_util.getProperty(this, 'documentElement');
  HTMLCollection getElementsByTagName(String qualifiedName) =>
      js_util.callMethod(this, 'getElementsByTagName', [qualifiedName]);

  HTMLCollection getElementsByTagNameNS(String? namespace, String localName) =>
      js_util
          .callMethod(this, 'getElementsByTagNameNS', [namespace, localName]);

  HTMLCollection getElementsByClassName(String classNames) =>
      js_util.callMethod(this, 'getElementsByClassName', [classNames]);

  Element createElement(String localName, [dynamic options]) =>
      js_util.callMethod(this, 'createElement', [localName, options]);

  Element createElementNS(String? namespace, String qualifiedName,
          [dynamic options]) =>
      js_util.callMethod(
          this, 'createElementNS', [namespace, qualifiedName, options]);

  DocumentFragment createDocumentFragment() =>
      js_util.callMethod(this, 'createDocumentFragment', []);

  Text createTextNode(String data) =>
      js_util.callMethod(this, 'createTextNode', [data]);

  CDATASection createCDATASection(String data) =>
      js_util.callMethod(this, 'createCDATASection', [data]);

  Comment createComment(String data) =>
      js_util.callMethod(this, 'createComment', [data]);

  ProcessingInstruction createProcessingInstruction(
          String target, String data) =>
      js_util.callMethod(this, 'createProcessingInstruction', [target, data]);

  Node importNode(Node node, [bool? deep = false]) =>
      js_util.callMethod(this, 'importNode', [node, deep]);

  Node adoptNode(Node node) => js_util.callMethod(this, 'adoptNode', [node]);

  Attr createAttribute(String localName) =>
      js_util.callMethod(this, 'createAttribute', [localName]);

  Attr createAttributeNS(String? namespace, String qualifiedName) =>
      js_util.callMethod(this, 'createAttributeNS', [namespace, qualifiedName]);

  Event createEvent(String interface) =>
      js_util.callMethod(this, 'createEvent', [interface]);

  Range createRange() => js_util.callMethod(this, 'createRange', []);

  NodeIterator createNodeIterator(Node root,
          [int? whatToShow = 0xFFFFFFFF, NodeFilter? filter]) =>
      js_util
          .callMethod(this, 'createNodeIterator', [root, whatToShow, filter]);

  TreeWalker createTreeWalker(Node root,
          [int? whatToShow = 0xFFFFFFFF, NodeFilter? filter]) =>
      js_util.callMethod(this, 'createTreeWalker', [root, whatToShow, filter]);

  SVGSVGElement? get rootElement => js_util.getProperty(this, 'rootElement');
  Future<bool> hasStorageAccess() =>
      js_util.promiseToFuture(js_util.callMethod(this, 'hasStorageAccess', []));

  Future<void> requestStorageAccess() => js_util
      .promiseToFuture(js_util.callMethod(this, 'requestStorageAccess', []));

  Selection? getSelection() => js_util.callMethod(this, 'getSelection', []);

  DocumentTimeline get timeline => js_util.getProperty(this, 'timeline');
  Element? elementFromPoint(double x, double y) =>
      js_util.callMethod(this, 'elementFromPoint', [x, y]);

  Iterable<Element> elementsFromPoint(double x, double y) =>
      js_util.callMethod(this, 'elementsFromPoint', [x, y]);

  CaretPosition? caretPositionFromPoint(double x, double y) =>
      js_util.callMethod(this, 'caretPositionFromPoint', [x, y]);

  Element? get scrollingElement =>
      js_util.getProperty(this, 'scrollingElement');
  EventHandlerNonNull? get onpointerlockchange =>
      js_util.getProperty(this, 'onpointerlockchange');
  set onpointerlockchange(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onpointerlockchange', newValue);
  }

  EventHandlerNonNull? get onpointerlockerror =>
      js_util.getProperty(this, 'onpointerlockerror');
  set onpointerlockerror(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onpointerlockerror', newValue);
  }

  void exitPointerLock() => js_util.callMethod(this, 'exitPointerLock', []);

  bool get fullscreenEnabled => js_util.getProperty(this, 'fullscreenEnabled');
  bool get fullscreen => js_util.getProperty(this, 'fullscreen');
  Future<void> exitFullscreen() =>
      js_util.promiseToFuture(js_util.callMethod(this, 'exitFullscreen', []));

  EventHandlerNonNull? get onfullscreenchange =>
      js_util.getProperty(this, 'onfullscreenchange');
  set onfullscreenchange(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onfullscreenchange', newValue);
  }

  EventHandlerNonNull? get onfullscreenerror =>
      js_util.getProperty(this, 'onfullscreenerror');
  set onfullscreenerror(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onfullscreenerror', newValue);
  }

  bool get pictureInPictureEnabled =>
      js_util.getProperty(this, 'pictureInPictureEnabled');
  Future<void> exitPictureInPicture() => js_util
      .promiseToFuture(js_util.callMethod(this, 'exitPictureInPicture', []));

  EventHandlerNonNull? get onfreeze => js_util.getProperty(this, 'onfreeze');
  set onfreeze(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onfreeze', newValue);
  }

  EventHandlerNonNull? get onresume => js_util.getProperty(this, 'onresume');
  set onresume(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onresume', newValue);
  }

  bool get wasDiscarded => js_util.getProperty(this, 'wasDiscarded');
  NamedFlowMap get namedFlows => js_util.getProperty(this, 'namedFlows');
  FragmentDirective get fragmentDirective =>
      js_util.getProperty(this, 'fragmentDirective');
  bool get prerendering => js_util.getProperty(this, 'prerendering');
  EventHandlerNonNull? get onprerenderingchange =>
      js_util.getProperty(this, 'onprerenderingchange');
  set onprerenderingchange(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onprerenderingchange', newValue);
  }

  PermissionsPolicy get permissionsPolicy =>
      js_util.getProperty(this, 'permissionsPolicy');
  Location? get location => js_util.getProperty(this, 'location');
  String get domain => js_util.getProperty(this, 'domain');
  set domain(String newValue) {
    js_util.setProperty(this, 'domain', newValue);
  }

  String get referrer => js_util.getProperty(this, 'referrer');
  String get cookie => js_util.getProperty(this, 'cookie');
  set cookie(String newValue) {
    js_util.setProperty(this, 'cookie', newValue);
  }

  String get lastModified => js_util.getProperty(this, 'lastModified');
  DocumentReadyState get readyState =>
      DocumentReadyState.fromValue(js_util.getProperty(this, 'readyState'));
  String get title => js_util.getProperty(this, 'title');
  set title(String newValue) {
    js_util.setProperty(this, 'title', newValue);
  }

  String get dir => js_util.getProperty(this, 'dir');
  set dir(String newValue) {
    js_util.setProperty(this, 'dir', newValue);
  }

  HTMLElement? get body => js_util.getProperty(this, 'body');
  set body(HTMLElement? newValue) {
    js_util.setProperty(this, 'body', newValue);
  }

  HTMLHeadElement? get head => js_util.getProperty(this, 'head');
  HTMLCollection get images => js_util.getProperty(this, 'images');
  HTMLCollection get embeds => js_util.getProperty(this, 'embeds');
  HTMLCollection get plugins => js_util.getProperty(this, 'plugins');
  HTMLCollection get links => js_util.getProperty(this, 'links');
  HTMLCollection get forms => js_util.getProperty(this, 'forms');
  HTMLCollection get scripts => js_util.getProperty(this, 'scripts');
  NodeList getElementsByName(String elementName) =>
      js_util.callMethod(this, 'getElementsByName', [elementName]);

  dynamic get currentScript => js_util.getProperty(this, 'currentScript');
  Window? open(String url, [String? name, String? features]) =>
      js_util.callMethod(this, 'open', [url, name, features]);

  void close() => js_util.callMethod(this, 'close', []);

  void write([String? text1, String? text2, String? text3]) =>
      js_util.callMethod(this, 'write', [text1, text2, text3]);

  void writeln([String? text1, String? text2, String? text3]) =>
      js_util.callMethod(this, 'writeln', [text1, text2, text3]);

  Window? get defaultView => js_util.getProperty(this, 'defaultView');
  bool hasFocus() => js_util.callMethod(this, 'hasFocus', []);

  String get designMode => js_util.getProperty(this, 'designMode');
  set designMode(String newValue) {
    js_util.setProperty(this, 'designMode', newValue);
  }

  bool execCommand(String commandId,
          [bool? showUI = false, String? value = '']) =>
      js_util.callMethod(this, 'execCommand', [commandId, showUI, value]);

  bool queryCommandEnabled(String commandId) =>
      js_util.callMethod(this, 'queryCommandEnabled', [commandId]);

  bool queryCommandIndeterm(String commandId) =>
      js_util.callMethod(this, 'queryCommandIndeterm', [commandId]);

  bool queryCommandState(String commandId) =>
      js_util.callMethod(this, 'queryCommandState', [commandId]);

  bool queryCommandSupported(String commandId) =>
      js_util.callMethod(this, 'queryCommandSupported', [commandId]);

  String queryCommandValue(String commandId) =>
      js_util.callMethod(this, 'queryCommandValue', [commandId]);

  bool get hidden => js_util.getProperty(this, 'hidden');
  DocumentVisibilityState get visibilityState =>
      DocumentVisibilityState.fromValue(
          js_util.getProperty(this, 'visibilityState'));
  EventHandlerNonNull? get onreadystatechange =>
      js_util.getProperty(this, 'onreadystatechange');
  set onreadystatechange(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onreadystatechange', newValue);
  }

  EventHandlerNonNull? get onvisibilitychange =>
      js_util.getProperty(this, 'onvisibilitychange');
  set onvisibilitychange(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onvisibilitychange', newValue);
  }

  String get fgColor => js_util.getProperty(this, 'fgColor');
  set fgColor(String newValue) {
    js_util.setProperty(this, 'fgColor', newValue);
  }

  String get linkColor => js_util.getProperty(this, 'linkColor');
  set linkColor(String newValue) {
    js_util.setProperty(this, 'linkColor', newValue);
  }

  String get vlinkColor => js_util.getProperty(this, 'vlinkColor');
  set vlinkColor(String newValue) {
    js_util.setProperty(this, 'vlinkColor', newValue);
  }

  String get alinkColor => js_util.getProperty(this, 'alinkColor');
  set alinkColor(String newValue) {
    js_util.setProperty(this, 'alinkColor', newValue);
  }

  String get bgColor => js_util.getProperty(this, 'bgColor');
  set bgColor(String newValue) {
    js_util.setProperty(this, 'bgColor', newValue);
  }

  HTMLCollection get anchors => js_util.getProperty(this, 'anchors');
  HTMLCollection get applets => js_util.getProperty(this, 'applets');
  void clear() => js_util.callMethod(this, 'clear', []);

  void captureEvents() => js_util.callMethod(this, 'captureEvents', []);

  void releaseEvents() => js_util.callMethod(this, 'releaseEvents', []);

  HTMLAllCollection get all => js_util.getProperty(this, 'all');
  FontMetrics measureElement(Element element) =>
      js_util.callMethod(this, 'measureElement', [element]);

  FontMetrics measureText(String text, StylePropertyMapReadOnly styleMap) =>
      js_util.callMethod(this, 'measureText', [text, styleMap]);
}

///  The XMLDocument interface represents an XML document. It
/// inherits from the generic [Document] and does not add any
/// specific methods or properties to it: nevertheless, several
/// algorithms behave differently with the two types of documents.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    Document
///
///
///
///
///
///    XMLDocument
///
///
@JS()
@staticInterop
class XMLDocument implements Document {
  external factory XMLDocument();
}

@anonymous
@JS()
@staticInterop
class ElementCreationOptions {
  external factory ElementCreationOptions({String? mIs});
}

extension PropsElementCreationOptions on ElementCreationOptions {
  @JS('is')
  @staticInterop
  String get mIs => js_util.getProperty(this, 'is');
  set mIs(String newValue) {
    js_util.setProperty(this, 'is', newValue);
  }
}

///  The interface represents an object providing methods which are
/// not dependent on any particular document. Such an object is
/// returned by the [Document.implementation] property.
@JS()
@staticInterop
class DOMImplementation {
  external factory DOMImplementation();
}

extension PropsDOMImplementation on DOMImplementation {
  DocumentType createDocumentType(
          String qualifiedName, String publicId, String systemId) =>
      js_util.callMethod(
          this, 'createDocumentType', [qualifiedName, publicId, systemId]);

  XMLDocument createDocument(String? namespace, String qualifiedName,
          [DocumentType? doctype]) =>
      js_util.callMethod(
          this, 'createDocument', [namespace, qualifiedName, doctype]);

  Document createHTMLDocument([String? title]) =>
      js_util.callMethod(this, 'createHTMLDocument', [title]);

  bool hasFeature() => js_util.callMethod(this, 'hasFeature', []);
}

/// The interface represents a [Node] containing a doctype.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    DocumentType
///
///
@JS()
@staticInterop
class DocumentType implements Node, ChildNode {
  external factory DocumentType();
}

extension PropsDocumentType on DocumentType {
  String get name => js_util.getProperty(this, 'name');
  String get publicId => js_util.getProperty(this, 'publicId');
  String get systemId => js_util.getProperty(this, 'systemId');
}

///  The interface represents a minimal document object that has no
/// parent.
///  It is used as a lightweight version of [Document] that stores a
/// segment of a document structure comprised of nodes just like a
/// standard document. The key difference is due to the fact that the
/// document fragment isn't part of the active document tree
/// structure. Changes made to the fragment don't affect the document
/// (even on reflow) or incur any performance impact when changes are
/// made.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    DocumentFragment
///
///
@JS()
@staticInterop
class DocumentFragment implements Node, NonElementParentNode, ParentNode {
  external factory DocumentFragment();
}

///  The interface of the Shadow DOM API is the root node of a DOM
/// subtree that is rendered separately from a document's main DOM
/// tree.
///  You can retrieve a reference to an element's shadow root using
/// its [Element.shadowRoot] property, provided it was created using
/// [Element.attachShadow()] with the [mode] option set to [open].
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    DocumentFragment
///
///
///
///
///
///    ShadowRoot
///
///
@JS()
@staticInterop
class ShadowRoot implements DocumentFragment, DocumentOrShadowRoot, InnerHTML {
  external factory ShadowRoot();
}

extension PropsShadowRoot on ShadowRoot {
  ShadowRootMode get mode =>
      ShadowRootMode.fromValue(js_util.getProperty(this, 'mode'));
  bool get delegatesFocus => js_util.getProperty(this, 'delegatesFocus');
  SlotAssignmentMode get slotAssignment =>
      SlotAssignmentMode.fromValue(js_util.getProperty(this, 'slotAssignment'));
  Element get host => js_util.getProperty(this, 'host');
  EventHandlerNonNull? get onslotchange =>
      js_util.getProperty(this, 'onslotchange');
  set onslotchange(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onslotchange', newValue);
  }
}

enum ShadowRootMode {
  open('open'),
  closed('closed');

  final String value;
  static ShadowRootMode fromValue(String value) =>
      values.firstWhere((e) => e.value == value);
  static Iterable<ShadowRootMode> fromValues(Iterable<String> values) =>
      values.map(fromValue);
  const ShadowRootMode(this.value);
}

enum SlotAssignmentMode {
  manual('manual'),
  named('named');

  final String value;
  static SlotAssignmentMode fromValue(String value) =>
      values.firstWhere((e) => e.value == value);
  static Iterable<SlotAssignmentMode> fromValues(Iterable<String> values) =>
      values.map(fromValue);
  const SlotAssignmentMode(this.value);
}

///   is the most general base class from which all element objects
/// (i.e. objects that represent elements) in a [Document] inherit.
/// It only has methods and properties common to all kinds of
/// elements. More specific classes inherit from .
///  For example, the [HTMLElement] interface is the base interface
/// for HTML elements, while the [SVGElement] interface is the basis
/// for all SVG elements. Most functionality is specified further
/// down the class hierarchy.
///  Languages outside the realm of the Web platform, like XUL
/// through the [XULElement] interface, also implement .
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    Element
///
///
@JS()
@staticInterop
class Element
    implements
        Node,
        Animatable,
        ARIAMixin,
        GeometryUtils,
        Region,
        ParentNode,
        NonDocumentTypeChildNode,
        ChildNode,
        Slottable,
        InnerHTML {
  external factory Element();
}

extension PropsElement on Element {
  String? get namespaceURI => js_util.getProperty(this, 'namespaceURI');
  String? get prefix => js_util.getProperty(this, 'prefix');
  String get localName => js_util.getProperty(this, 'localName');
  String get tagName => js_util.getProperty(this, 'tagName');
  String get id => js_util.getProperty(this, 'id');
  set id(String newValue) {
    js_util.setProperty(this, 'id', newValue);
  }

  dynamic get className => js_util.getProperty(this, 'className');
  set className(dynamic newValue) {
    js_util.setProperty(this, 'className', newValue);
  }

  DOMTokenList get classList => js_util.getProperty(this, 'classList');
  String get slot => js_util.getProperty(this, 'slot');
  set slot(String newValue) {
    js_util.setProperty(this, 'slot', newValue);
  }

  bool hasAttributes() => js_util.callMethod(this, 'hasAttributes', []);

  NamedNodeMap get attributes => js_util.getProperty(this, 'attributes');
  Iterable<String> getAttributeNames() =>
      js_util.callMethod(this, 'getAttributeNames', []);

  String? getAttribute(String qualifiedName) =>
      js_util.callMethod(this, 'getAttribute', [qualifiedName]);

  String? getAttributeNS(String? namespace, String localName) =>
      js_util.callMethod(this, 'getAttributeNS', [namespace, localName]);

  void setAttribute(String qualifiedName, String value) =>
      js_util.callMethod(this, 'setAttribute', [qualifiedName, value]);

  void setAttributeNS(String? namespace, String qualifiedName, String value) =>
      js_util.callMethod(
          this, 'setAttributeNS', [namespace, qualifiedName, value]);

  void removeAttribute(String qualifiedName) =>
      js_util.callMethod(this, 'removeAttribute', [qualifiedName]);

  void removeAttributeNS(String? namespace, String localName) =>
      js_util.callMethod(this, 'removeAttributeNS', [namespace, localName]);

  bool toggleAttribute(String qualifiedName, [bool? force]) =>
      js_util.callMethod(this, 'toggleAttribute', [qualifiedName, force]);

  bool hasAttribute(String qualifiedName) =>
      js_util.callMethod(this, 'hasAttribute', [qualifiedName]);

  bool hasAttributeNS(String? namespace, String localName) =>
      js_util.callMethod(this, 'hasAttributeNS', [namespace, localName]);

  Attr? getAttributeNode(String qualifiedName) =>
      js_util.callMethod(this, 'getAttributeNode', [qualifiedName]);

  Attr? getAttributeNodeNS(String? namespace, String localName) =>
      js_util.callMethod(this, 'getAttributeNodeNS', [namespace, localName]);

  Attr? setAttributeNode(Attr attr) =>
      js_util.callMethod(this, 'setAttributeNode', [attr]);

  Attr? setAttributeNodeNS(Attr attr) =>
      js_util.callMethod(this, 'setAttributeNodeNS', [attr]);

  Attr removeAttributeNode(Attr attr) =>
      js_util.callMethod(this, 'removeAttributeNode', [attr]);

  ShadowRoot attachShadow(ShadowRootInit init) =>
      js_util.callMethod(this, 'attachShadow', [init]);

  ShadowRoot? get shadowRoot => js_util.getProperty(this, 'shadowRoot');
  Element? closest(String selectors) =>
      js_util.callMethod(this, 'closest', [selectors]);

  bool matches(String selectors) =>
      js_util.callMethod(this, 'matches', [selectors]);

  bool webkitMatchesSelector(String selectors) =>
      js_util.callMethod(this, 'webkitMatchesSelector', [selectors]);

  HTMLCollection getElementsByTagName(String qualifiedName) =>
      js_util.callMethod(this, 'getElementsByTagName', [qualifiedName]);

  HTMLCollection getElementsByTagNameNS(String? namespace, String localName) =>
      js_util
          .callMethod(this, 'getElementsByTagNameNS', [namespace, localName]);

  HTMLCollection getElementsByClassName(String classNames) =>
      js_util.callMethod(this, 'getElementsByClassName', [classNames]);

  Element? insertAdjacentElement(String where, Element element) =>
      js_util.callMethod(this, 'insertAdjacentElement', [where, element]);

  void insertAdjacentText(String where, String data) =>
      js_util.callMethod(this, 'insertAdjacentText', [where, data]);

  StylePropertyMapReadOnly computedStyleMap() =>
      js_util.callMethod(this, 'computedStyleMap', []);

  DOMRectList getClientRects() =>
      js_util.callMethod(this, 'getClientRects', []);

  DOMRect getBoundingClientRect() =>
      js_util.callMethod(this, 'getBoundingClientRect', []);

  bool checkVisibility([CheckVisibilityOptions? options]) =>
      js_util.callMethod(this, 'checkVisibility', [options]);

  void scrollIntoView([dynamic arg]) =>
      js_util.callMethod(this, 'scrollIntoView', [arg]);

  void scroll([/* double | NaN */ dynamic x, /* double | NaN */ dynamic y]) =>
      js_util.callMethod(this, 'scroll', [x, y]);

  void scrollTo([/* double | NaN */ dynamic x, /* double | NaN */ dynamic y]) =>
      js_util.callMethod(this, 'scrollTo', [x, y]);

  void scrollBy([/* double | NaN */ dynamic x, /* double | NaN */ dynamic y]) =>
      js_util.callMethod(this, 'scrollBy', [x, y]);

/* double | NaN */ dynamic get scrollTop =>
      js_util.getProperty(this, 'scrollTop');
  set scrollTop(/* double | NaN */ dynamic newValue) {
    js_util.setProperty(this, 'scrollTop', newValue);
  }

/* double | NaN */ dynamic get scrollLeft =>
      js_util.getProperty(this, 'scrollLeft');
  set scrollLeft(/* double | NaN */ dynamic newValue) {
    js_util.setProperty(this, 'scrollLeft', newValue);
  }

  int get scrollWidth => js_util.getProperty(this, 'scrollWidth');
  int get scrollHeight => js_util.getProperty(this, 'scrollHeight');
  int get clientTop => js_util.getProperty(this, 'clientTop');
  int get clientLeft => js_util.getProperty(this, 'clientLeft');
  int get clientWidth => js_util.getProperty(this, 'clientWidth');
  int get clientHeight => js_util.getProperty(this, 'clientHeight');
  void requestPointerLock() =>
      js_util.callMethod(this, 'requestPointerLock', []);

  Future<void> requestFullscreen([FullscreenOptions? options]) =>
      js_util.promiseToFuture(
          js_util.callMethod(this, 'requestFullscreen', [options]));

  EventHandlerNonNull? get onfullscreenchange =>
      js_util.getProperty(this, 'onfullscreenchange');
  set onfullscreenchange(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onfullscreenchange', newValue);
  }

  EventHandlerNonNull? get onfullscreenerror =>
      js_util.getProperty(this, 'onfullscreenerror');
  set onfullscreenerror(EventHandlerNonNull? newValue) {
    js_util.setProperty(this, 'onfullscreenerror', newValue);
  }

  void setPointerCapture(int pointerId) =>
      js_util.callMethod(this, 'setPointerCapture', [pointerId]);

  void releasePointerCapture(int pointerId) =>
      js_util.callMethod(this, 'releasePointerCapture', [pointerId]);

  bool hasPointerCapture(int pointerId) =>
      js_util.callMethod(this, 'hasPointerCapture', [pointerId]);

  CSSPseudoElement? pseudo(String type) =>
      js_util.callMethod(this, 'pseudo', [type]);

  String get outerHTML => js_util.getProperty(this, 'outerHTML');
  set outerHTML(String newValue) {
    js_util.setProperty(this, 'outerHTML', newValue);
  }

  void insertAdjacentHTML(String position, String text) =>
      js_util.callMethod(this, 'insertAdjacentHTML', [position, text]);

  String get elementTiming => js_util.getProperty(this, 'elementTiming');
  set elementTiming(String newValue) {
    js_util.setProperty(this, 'elementTiming', newValue);
  }

  Node getSpatialNavigationContainer() =>
      js_util.callMethod(this, 'getSpatialNavigationContainer', []);

  Iterable<Node> focusableAreas([FocusableAreasOption? option]) =>
      js_util.callMethod(this, 'focusableAreas', [option]);

  Node? spatialNavigationSearch(SpatialNavigationDirection dir,
          [SpatialNavigationSearchOptions? options]) =>
      js_util.callMethod(this, 'spatialNavigationSearch', [dir.value, options]);

  void setHTML(String input, [SetHTMLOptions? options]) =>
      js_util.callMethod(this, 'setHTML', [input, options]);

  DOMTokenList get part => js_util.getProperty(this, 'part');
  EditContext? get editContext => js_util.getProperty(this, 'editContext');
  set editContext(EditContext? newValue) {
    js_util.setProperty(this, 'editContext', newValue);
  }
}

@anonymous
@JS()
@staticInterop
class ShadowRootInit {
  external factory ShadowRootInit._(
      {required String mode, bool? delegatesFocus, String? slotAssignment});

  factory ShadowRootInit(
          {required ShadowRootMode mode,
          bool? delegatesFocus,
          SlotAssignmentMode? slotAssignment}) =>
      ShadowRootInit._(
          mode: mode.value,
          delegatesFocus: delegatesFocus ?? false,
          slotAssignment:
              slotAssignment?.value ?? SlotAssignmentMode.named.value);
}

extension PropsShadowRootInit on ShadowRootInit {
  ShadowRootMode get mode =>
      ShadowRootMode.fromValue(js_util.getProperty(this, 'mode'));
  set mode(ShadowRootMode newValue) {
    js_util.setProperty(this, 'mode', newValue.value);
  }

  bool get delegatesFocus => js_util.getProperty(this, 'delegatesFocus');
  set delegatesFocus(bool newValue) {
    js_util.setProperty(this, 'delegatesFocus', newValue);
  }

  SlotAssignmentMode get slotAssignment =>
      SlotAssignmentMode.fromValue(js_util.getProperty(this, 'slotAssignment'));
  set slotAssignment(SlotAssignmentMode newValue) {
    js_util.setProperty(this, 'slotAssignment', newValue.value);
  }
}

///  The interface represents a collection of [Attr] objects. Objects
/// inside a are not in any particular order, unlike [NodeList],
/// although they may be accessed by an index as in an array.
///  A object is live and will thus be auto-updated if changes are
/// made to its contents internally or elsewhere.
///
///   Note: Although called , this interface doesn't deal with [Node]
/// objects but with [Attr] objects, which were originally a
/// specialized class of [Node], and still are in some
/// implementations.
///
@JS()
@staticInterop
class NamedNodeMap {
  external factory NamedNodeMap();
}

extension PropsNamedNodeMap on NamedNodeMap {
  int get length => js_util.getProperty(this, 'length');
  Attr? item(int index) => js_util.callMethod(this, 'item', [index]);

  Attr? getNamedItem(String qualifiedName) =>
      js_util.callMethod(this, 'getNamedItem', [qualifiedName]);

  Attr? getNamedItemNS(String? namespace, String localName) =>
      js_util.callMethod(this, 'getNamedItemNS', [namespace, localName]);

  Attr? setNamedItem(Attr attr) =>
      js_util.callMethod(this, 'setNamedItem', [attr]);

  Attr? setNamedItemNS(Attr attr) =>
      js_util.callMethod(this, 'setNamedItemNS', [attr]);

  Attr removeNamedItem(String qualifiedName) =>
      js_util.callMethod(this, 'removeNamedItem', [qualifiedName]);

  Attr removeNamedItemNS(String? namespace, String localName) =>
      js_util.callMethod(this, 'removeNamedItemNS', [namespace, localName]);
}

///  The interface represents one of an element's attributes as an
/// object. In most situations, you will directly retrieve the
/// attribute value as a string (e.g., [Element.getAttribute()]), but
/// certain functions (e.g., [Element.getAttributeNode()]) or means
/// of iterating return instances.
///  The core idea of an object of type is the association between a
/// name and a value. An attribute may also be part of a namespace
/// and, in this case, it also has a URI identifying the namespace,
/// and a prefix that is an abbreviation for the namespace.
///  The name is deemed local when it ignores the eventual namespace
/// prefix and deemed qualified when it includes the prefix of the
/// namespace, if any, separated from the local name by a colon
/// ([:]). We have three cases: an attribute outside of a namespace,
/// an attribute inside a namespace without a prefix defined, an
/// attribute inside a namespace with a prefix:
///
///
///
///    Attribute
///    Namespace name
///    Namespace prefix
///    Attribute local name
///    Attribute qualified name
///
///
///
///
///    [myAttr]
///    none
///    none
///    [myAttr]
///    [myAttr]
///
///
///    [myAttr]
///    [mynamespace]
///    none
///    [myAttr]
///    [myAttr]
///
///
///    [myAttr]
///    [mynamespace]
///    [myns]
///    [myAttr]
///    [myns:myAttr]
///
///
///
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    Attr
///
///
///
///   Note: This interface represents only attributes present in the
/// tree representation of the [Element], being a SVG, an HTML or a
/// MathML element. It doesn't represent the property of an interface
/// associated with such element, such as [HTMLTableElement] for a
/// [<table>] element. (See this article for more information about
/// attributes and how they are reflected into properties.)
///
@JS()
@staticInterop
class Attr implements Node {
  external factory Attr();
}

extension PropsAttr on Attr {
  String? get namespaceURI => js_util.getProperty(this, 'namespaceURI');
  String? get prefix => js_util.getProperty(this, 'prefix');
  String get localName => js_util.getProperty(this, 'localName');
  String get name => js_util.getProperty(this, 'name');
  String get value => js_util.getProperty(this, 'value');
  set value(String newValue) {
    js_util.setProperty(this, 'value', newValue);
  }

  Element? get ownerElement => js_util.getProperty(this, 'ownerElement');
  bool get specified => js_util.getProperty(this, 'specified');
}

///  The abstract interface represents a [Node] object that contains
/// characters. This is an abstract interface, meaning there aren't
/// any objects of type : it is implemented by other interfaces like
/// [Text], [Comment], [CDATASection], or [ProcessingInstruction],
/// which aren't abstract.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    CharacterData
///
///
@JS()
@staticInterop
class CharacterData implements Node, NonDocumentTypeChildNode, ChildNode {
  external factory CharacterData();
}

extension PropsCharacterData on CharacterData {
  String get data => js_util.getProperty(this, 'data');
  set data(String newValue) {
    js_util.setProperty(this, 'data', newValue);
  }

  int get length => js_util.getProperty(this, 'length');
  String substringData(int offset, int count) =>
      js_util.callMethod(this, 'substringData', [offset, count]);

  void appendData(String data) =>
      js_util.callMethod(this, 'appendData', [data]);

  void insertData(int offset, String data) =>
      js_util.callMethod(this, 'insertData', [offset, data]);

  void deleteData(int offset, int count) =>
      js_util.callMethod(this, 'deleteData', [offset, count]);

  void replaceData(int offset, int count, String data) =>
      js_util.callMethod(this, 'replaceData', [offset, count, data]);
}

/// The interface represents a text [node] in a DOM tree.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    CharacterData
///
///
///
///
///
///    Text
///
///
///  To understand what a text node is, consider the following
/// document:
/// [<html class="e"><head><title>Aliens?</title></head>
///  <body>Why yes.
/// </body></html>
/// ]
///  In that document, there are three text nodes, with the following
/// contents:
///
///  "[Aliens?]" (the contents of the [title] element)
///   "[\n]" (after the [</head>] end tag, a newline followed by a
/// space)
///  "[Why yes.\n]" (the contents of the [body] element)
///
///  Each of those text nodes is an object that has the properties
/// and methods documented in this article.
@JS()
@staticInterop
class Text implements CharacterData, GeometryUtils, Slottable {
  external factory Text._([String? data = '']);

  factory Text([String? data = '']) => Text._(data ?? '');
}

extension PropsText on Text {
  Text splitText(int offset) => js_util.callMethod(this, 'splitText', [offset]);

  String get wholeText => js_util.getProperty(this, 'wholeText');
}

///
///  The interface represents a CDATA section
///   that can be used within XML to include extended portions of
/// unescaped text.
///   When inside a CDATA section, the symbols [<] and [&] don't need
/// escaping
///  as they normally do.
///
/// In XML, a CDATA section looks like:
/// [<![CDATA[ ... ]]>
/// ]
/// For example:
///  [<foo>Here is a CDATA section: <![CDATA[ < > & ]]> with all
/// kinds of unescaped text.</foo>
/// ]
///
///   The only sequence which is not allowed within a CDATA section
/// is the closing sequence
///  of a CDATA section itself, []]>].
///   Note: CDATA sections should not be used within HTML they are
/// considered as comments and not displayed.
///
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    CharacterData
///
///
///
///
///
///    Text
///
///
///
///
///
///    CDATASection
///
///
@JS()
@staticInterop
class CDATASection implements Text {
  external factory CDATASection();
}

///  The interface represents a processing instruction; that is, a
/// [Node] which embeds an instruction targeting a specific
/// application but that can be ignored by any other applications
/// which don't recognize the instruction.
///
///   Warning: nodes are only supported in XML documents, not in HTML
/// documents. In these, a process instruction will be considered as
/// a comment and be represented as a [Comment] object in the tree.
///
///  A processing instruction may be different than the XML
/// declaration.
///
///   Note: User-defined processing instructions cannot begin with
/// "[xml]", as [xml]-prefixed processing-instruction target names
/// are reserved by the XML specification for particular, standard
/// uses (see, for example, [<?xml-stylesheet ?>].
///
/// For example:
/// [<?xml version="1.0"?>
/// ]
/// is a processing instruction whose [target]is [xml].
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    CharacterData
///
///
///
///
///
///    ProcessingInstruction
///
///
@JS()
@staticInterop
class ProcessingInstruction implements CharacterData, LinkStyle {
  external factory ProcessingInstruction();
}

extension PropsProcessingInstruction on ProcessingInstruction {
  String get target => js_util.getProperty(this, 'target');
}

///  The interface represents textual notations within markup;
/// although it is generally not visually shown, such comments are
/// available to be read in the source view.
///  Comments are represented in HTML and XML as content between
/// '[<!--]' and '[-->]'. In XML, like inside SVG or MathML markup,
/// the character sequence '[--]' cannot be used within a comment.
///
///
///
///    EventTarget
///
///
///
///
///
///    Node
///
///
///
///
///
///    CharacterData
///
///
///
///
///
///    Comment
///
///
@JS()
@staticInterop
class Comment implements CharacterData {
  external factory Comment._([String? data = '']);

  factory Comment([String? data = '']) => Comment._(data ?? '');
}

///  The abstract interface is the base class upon which all DOM
/// range types are defined. A range is an object that indicates the
/// start and end points of a section of content within the document.
///
///   Note: As an abstract interface, you will not directly
/// instantiate an object of type . Instead, you will use the [Range]
/// or [StaticRange] interfaces. To understand the difference between
/// those two interfaces, and how to choose which is appropriate for
/// your needs.
///
@JS()
@staticInterop
class AbstractRange {
  external factory AbstractRange();
}

extension PropsAbstractRange on AbstractRange {
  Node get startContainer => js_util.getProperty(this, 'startContainer');
  int get startOffset => js_util.getProperty(this, 'startOffset');
  Node get endContainer => js_util.getProperty(this, 'endContainer');
  int get endOffset => js_util.getProperty(this, 'endOffset');
  bool get collapsed => js_util.getProperty(this, 'collapsed');
}

@anonymous
@JS()
@staticInterop
class StaticRangeInit {
  external factory StaticRangeInit(
      {required Node startContainer,
      required int startOffset,
      required Node endContainer,
      required int endOffset});
}

extension PropsStaticRangeInit on StaticRangeInit {
  Node get startContainer => js_util.getProperty(this, 'startContainer');
  set startContainer(Node newValue) {
    js_util.setProperty(this, 'startContainer', newValue);
  }

  int get startOffset => js_util.getProperty(this, 'startOffset');
  set startOffset(int newValue) {
    js_util.setProperty(this, 'startOffset', newValue);
  }

  Node get endContainer => js_util.getProperty(this, 'endContainer');
  set endContainer(Node newValue) {
    js_util.setProperty(this, 'endContainer', newValue);
  }

  int get endOffset => js_util.getProperty(this, 'endOffset');
  set endOffset(int newValue) {
    js_util.setProperty(this, 'endOffset', newValue);
  }
}

///  The DOM interface extends [AbstractRange] to provide a method to
/// specify a range of content in the DOM whose contents don't update
/// to reflect changes which occur within the DOM tree.
///  This interface offers the same set of properties and methods as
/// [AbstractRange].
/// [AbstractRange] and are not available from web workers.
///
///
///
///    AbstractRange
///
///
///
///
///
///    StaticRange
///
///
@JS()
@staticInterop
class StaticRange implements AbstractRange {
  external factory StaticRange(StaticRangeInit init);
}

///  The interface represents a fragment of a document that can
/// contain nodes and parts of text nodes.
///  A range can be created by using the [Document.createRange()]
/// method. Range objects can also be retrieved by using the
/// [getRangeAt()] method of the [Selection] object or the
/// [caretRangeFromPoint()] method of the [Document] object.
/// There also is the [Range()] constructor available.
///
///
///
///    AbstractRange
///
///
///
///
///
///    Range
///
///
@JS()
@staticInterop
class Range implements AbstractRange {
  @JS('START_TO_START')
  external static int get startToStart;

  @JS('START_TO_END')
  external static int get startToEnd;

  @JS('END_TO_END')
  external static int get endToEnd;

  @JS('END_TO_START')
  external static int get endToStart;

  external factory Range();
}

extension PropsRange on Range {
  Node get commonAncestorContainer =>
      js_util.getProperty(this, 'commonAncestorContainer');
  void setStart(Node node, int offset) =>
      js_util.callMethod(this, 'setStart', [node, offset]);

  void setEnd(Node node, int offset) =>
      js_util.callMethod(this, 'setEnd', [node, offset]);

  void setStartBefore(Node node) =>
      js_util.callMethod(this, 'setStartBefore', [node]);

  void setStartAfter(Node node) =>
      js_util.callMethod(this, 'setStartAfter', [node]);

  void setEndBefore(Node node) =>
      js_util.callMethod(this, 'setEndBefore', [node]);

  void setEndAfter(Node node) =>
      js_util.callMethod(this, 'setEndAfter', [node]);

  void collapse([bool? toStart = false]) =>
      js_util.callMethod(this, 'collapse', [toStart]);

  void selectNode(Node node) => js_util.callMethod(this, 'selectNode', [node]);

  void selectNodeContents(Node node) =>
      js_util.callMethod(this, 'selectNodeContents', [node]);

  int compareBoundaryPoints(int how, Range sourceRange) =>
      js_util.callMethod(this, 'compareBoundaryPoints', [how, sourceRange]);

  void deleteContents() => js_util.callMethod(this, 'deleteContents', []);

  DocumentFragment extractContents() =>
      js_util.callMethod(this, 'extractContents', []);

  DocumentFragment cloneContents() =>
      js_util.callMethod(this, 'cloneContents', []);

  void insertNode(Node node) => js_util.callMethod(this, 'insertNode', [node]);

  void surroundContents(Node newParent) =>
      js_util.callMethod(this, 'surroundContents', [newParent]);

  Range cloneRange() => js_util.callMethod(this, 'cloneRange', []);

  void detach() => js_util.callMethod(this, 'detach', []);

  bool isPointInRange(Node node, int offset) =>
      js_util.callMethod(this, 'isPointInRange', [node, offset]);

  int comparePoint(Node node, int offset) =>
      js_util.callMethod(this, 'comparePoint', [node, offset]);

  bool intersectsNode(Node node) =>
      js_util.callMethod(this, 'intersectsNode', [node]);

  String mToString() => js_util.callMethod(this, 'toString', []);

  DOMRectList getClientRects() =>
      js_util.callMethod(this, 'getClientRects', []);

  DOMRect getBoundingClientRect() =>
      js_util.callMethod(this, 'getBoundingClientRect', []);

  DocumentFragment createContextualFragment(String fragment) =>
      js_util.callMethod(this, 'createContextualFragment', [fragment]);
}

///
///  The interface
///   represents an iterator over the members of a list of the nodes
/// in a subtree of the
///  DOM. The nodes will be returned in document order.
///
@JS()
@staticInterop
class NodeIterator {
  external factory NodeIterator();
}

extension PropsNodeIterator on NodeIterator {
  Node get root => js_util.getProperty(this, 'root');
  Node get referenceNode => js_util.getProperty(this, 'referenceNode');
  bool get pointerBeforeReferenceNode =>
      js_util.getProperty(this, 'pointerBeforeReferenceNode');
  int get whatToShow => js_util.getProperty(this, 'whatToShow');
  NodeFilter? get filter => js_util.getProperty(this, 'filter');
  Node? nextNode() => js_util.callMethod(this, 'nextNode', []);

  Node? previousNode() => js_util.callMethod(this, 'previousNode', []);

  void detach() => js_util.callMethod(this, 'detach', []);
}

///  The object represents the nodes of a document subtree and a
/// position within them.
/// A can be created using the [Document.createTreeWalker()] method.
@JS()
@staticInterop
class TreeWalker {
  external factory TreeWalker();
}

extension PropsTreeWalker on TreeWalker {
  Node get root => js_util.getProperty(this, 'root');
  int get whatToShow => js_util.getProperty(this, 'whatToShow');
  NodeFilter? get filter => js_util.getProperty(this, 'filter');
  Node get currentNode => js_util.getProperty(this, 'currentNode');
  set currentNode(Node newValue) {
    js_util.setProperty(this, 'currentNode', newValue);
  }

  Node? parentNode() => js_util.callMethod(this, 'parentNode', []);

  Node? firstChild() => js_util.callMethod(this, 'firstChild', []);

  Node? lastChild() => js_util.callMethod(this, 'lastChild', []);

  Node? previousSibling() => js_util.callMethod(this, 'previousSibling', []);

  Node? nextSibling() => js_util.callMethod(this, 'nextSibling', []);

  Node? previousNode() => js_util.callMethod(this, 'previousNode', []);

  Node? nextNode() => js_util.callMethod(this, 'nextNode', []);
}

///  A interface represents an object used to filter the nodes in a
/// [NodeIterator] or [TreeWalker]. A knows nothing about the
/// document or traversing nodes; it only knows how to evaluate a
/// single node against the provided filter.
///
///   Note: The browser doesn't provide any object implementing this
/// interface. It is the user who is expected to write one, tailoring
/// the [acceptNode()] method to its needs, and using it with some
/// [TreeWalker] or [NodeIterator] objects.
///
@JS()
@staticInterop
class NodeFilter {
  @JS('FILTER_ACCEPT')
  external static int get filterAccept;

  @JS('FILTER_REJECT')
  external static int get filterReject;

  @JS('FILTER_SKIP')
  external static int get filterSkip;

  @JS('SHOW_ALL')
  external static int get showAll;

  @JS('SHOW_ELEMENT')
  external static int get showElement;

  @JS('SHOW_ATTRIBUTE')
  external static int get showAttribute;

  @JS('SHOW_TEXT')
  external static int get showText;

  @JS('SHOW_CDATA_SECTION')
  external static int get showCdataSection;

  @JS('SHOW_ENTITY_REFERENCE')
  external static int get showEntityReference;

  @JS('SHOW_ENTITY')
  external static int get showEntity;

  @JS('SHOW_PROCESSING_INSTRUCTION')
  external static int get showProcessingInstruction;

  @JS('SHOW_COMMENT')
  external static int get showComment;

  @JS('SHOW_DOCUMENT')
  external static int get showDocument;

  @JS('SHOW_DOCUMENT_TYPE')
  external static int get showDocumentType;

  @JS('SHOW_DOCUMENT_FRAGMENT')
  external static int get showDocumentFragment;

  @JS('SHOW_NOTATION')
  external static int get showNotation;

  external factory NodeFilter();
}

extension PropsNodeFilter on NodeFilter {
  int acceptNode(Node node) => js_util.callMethod(this, 'acceptNode', [node]);
}

///  The interface represents a set of space-separated tokens. Such a
/// set is returned by [Element.classList] or
/// [HTMLLinkElement.relList], and many others.
///  A is indexed beginning with [0] as with JavaScript [Array]
/// objects. is always case-sensitive.
@JS()
@staticInterop
class DOMTokenList extends JsArray<String> {
  external factory DOMTokenList();
}

extension PropsDOMTokenList on DOMTokenList {
  int get length => js_util.getProperty(this, 'length');
  String? item(int index) => js_util.callMethod(this, 'item', [index]);

  bool contains(String token) => js_util.callMethod(this, 'contains', [token]);

  void add([String? tokens1, String? tokens2, String? tokens3]) =>
      js_util.callMethod(this, 'add', [tokens1, tokens2, tokens3]);

  void remove([String? tokens1, String? tokens2, String? tokens3]) =>
      js_util.callMethod(this, 'remove', [tokens1, tokens2, tokens3]);

  bool toggle(String token, [bool? force]) =>
      js_util.callMethod(this, 'toggle', [token, force]);

  bool replace(String token, String newToken) =>
      js_util.callMethod(this, 'replace', [token, newToken]);

  bool supports(String token) => js_util.callMethod(this, 'supports', [token]);

  String get value => js_util.getProperty(this, 'value');
  set value(String newValue) {
    js_util.setProperty(this, 'value', newValue);
  }
}

///  The interface represents the results generated by evaluating an
/// XPath expression within the context of a given node.
///  Since XPath expressions can result in a variety of result types,
/// this interface makes it possible to determine and handle the type
/// and value of the result.
@JS()
@staticInterop
class XPathResult {
  @JS('ANY_TYPE')
  external static int get anyType;

  @JS('NUMBER_TYPE')
  external static int get numberType;

  @JS('STRING_TYPE')
  external static int get stringType;

  @JS('BOOLEAN_TYPE')
  external static int get booleanType;

  @JS('UNORDERED_NODE_ITERATOR_TYPE')
  external static int get unorderedNodeIteratorType;

  @JS('ORDERED_NODE_ITERATOR_TYPE')
  external static int get orderedNodeIteratorType;

  @JS('UNORDERED_NODE_SNAPSHOT_TYPE')
  external static int get unorderedNodeSnapshotType;

  @JS('ORDERED_NODE_SNAPSHOT_TYPE')
  external static int get orderedNodeSnapshotType;

  @JS('ANY_UNORDERED_NODE_TYPE')
  external static int get anyUnorderedNodeType;

  @JS('FIRST_ORDERED_NODE_TYPE')
  external static int get firstOrderedNodeType;

  external factory XPathResult();
}

extension PropsXPathResult on XPathResult {
  int get resultType => js_util.getProperty(this, 'resultType');
/* double | NaN */ dynamic get numberValue =>
      js_util.getProperty(this, 'numberValue');
  String get stringValue => js_util.getProperty(this, 'stringValue');
  bool get booleanValue => js_util.getProperty(this, 'booleanValue');
  Node? get singleNodeValue => js_util.getProperty(this, 'singleNodeValue');
  bool get invalidIteratorState =>
      js_util.getProperty(this, 'invalidIteratorState');
  int get snapshotLength => js_util.getProperty(this, 'snapshotLength');
  Node? iterateNext() => js_util.callMethod(this, 'iterateNext', []);

  Node? snapshotItem(int index) =>
      js_util.callMethod(this, 'snapshotItem', [index]);
}

///  This interface is a compiled XPath expression that can be
/// evaluated on a document or specific node to return information
/// from its DOM tree.
///  This is useful when an expression will be reused in an
/// application, because it is just compiled once and all namespace
/// prefixes which occur within the expression are preresolved.
///  Objects of this type are created by calling
/// [XPathEvaluator.createExpression()].
@JS()
@staticInterop
class XPathExpression {
  external factory XPathExpression();
}

extension PropsXPathExpression on XPathExpression {
  XPathResult evaluate(Node contextNode,
          [int? type = 0, XPathResult? result]) =>
      js_util.callMethod(this, 'evaluate', [contextNode, type, result]);
}

///  The interface permits prefix strings in an XPath expression to
/// be properly bound to namespace URI strings.
///  The [XPathEvaluator] interface can construct an implementation
/// of from a node, or the interface may be implemented by any
/// application.
@JS()
@staticInterop
class XPathNSResolver {
  external factory XPathNSResolver();
}

extension PropsXPathNSResolver on XPathNSResolver {
  String? lookupNamespaceURI(String? prefix) =>
      js_util.callMethod(this, 'lookupNamespaceURI', [prefix]);
}

@JS()
@staticInterop
class XPathEvaluatorBase {
  external factory XPathEvaluatorBase();
}

extension PropsXPathEvaluatorBase on XPathEvaluatorBase {
  XPathExpression createExpression(String expression,
          [XPathNSResolver? resolver]) =>
      js_util.callMethod(this, 'createExpression', [expression, resolver]);

  XPathNSResolver createNSResolver(Node nodeResolver) =>
      js_util.callMethod(this, 'createNSResolver', [nodeResolver]);

  XPathResult evaluate(String expression, Node contextNode,
          [XPathNSResolver? resolver, int? type = 0, XPathResult? result]) =>
      js_util.callMethod(
          this, 'evaluate', [expression, contextNode, resolver, type, result]);
}

/// The interface allows to compile and evaluate XPath expressions.
/// It is implemented by the [Document] interface.
@JS()
@staticInterop
class XPathEvaluator implements XPathEvaluatorBase {
  external factory XPathEvaluator();
}

///  Non-standard: This feature is non-standard and is not on a
/// standards track. Do not use it on production sites facing the
/// Web: it will not work for every user. There may also be large
/// incompatibilities between implementations and the behavior may
/// change in the future.Experimental: This is an experimental
/// technologyCheck the Browser compatibility table carefully before
/// using this in production.
///
///   An applies an XSLT stylesheet transformation to an XML document
/// to
///   produce a new XML document as output. It has methods to load
/// the XSLT stylesheet, to
///  manipulate [<xsl:param>] parameter values, and to apply the
///  transformation to documents.
///
@JS()
@staticInterop
class XSLTProcessor {
  external factory XSLTProcessor();
}

extension PropsXSLTProcessor on XSLTProcessor {
  void importStylesheet(Node style) =>
      js_util.callMethod(this, 'importStylesheet', [style]);

  DocumentFragment transformToFragment(Node source, Document output) =>
      js_util.callMethod(this, 'transformToFragment', [source, output]);

  Document transformToDocument(Node source) =>
      js_util.callMethod(this, 'transformToDocument', [source]);

  void setParameter(String namespaceURI, String localName, dynamic value) =>
      js_util
          .callMethod(this, 'setParameter', [namespaceURI, localName, value]);

  dynamic getParameter(String namespaceURI, String localName) =>
      js_util.callMethod(this, 'getParameter', [namespaceURI, localName]);

  void removeParameter(String namespaceURI, String localName) =>
      js_util.callMethod(this, 'removeParameter', [namespaceURI, localName]);

  void clearParameters() => js_util.callMethod(this, 'clearParameters', []);

  void reset() => js_util.callMethod(this, 'reset', []);
}
